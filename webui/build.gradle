plugins {
    id 'java'
    id 'application'
    id 'com.vaadin' version '0.14.3.7'
}

def jettyVersion = "9.4.35.v20201120"

repositories {
    jcenter()
}

dependencies {
    compile 'org.vaadin.addons:googleanalyticstracker:4.0.1'

    compile libraries.slf4j
    compile libraries.libjson

    compile project(":webshared")

    compile (
            "com.rollbar:rollbar-java:1.6.0",
            "io.reactivex:rxscala_2.12:0.26.5"
    )

    compile project(":connectors-editors:basecamp-editor")
    compile project(":connectors-editors:basecamp-classic-editor")
    compile project(":connectors-editors:github-editor")
    compile project(":connectors-editors:jira-editor")
    compile project(":connectors-editors:mantis-editor")
    compile project(":connectors-editors:msp-editor")
    compile project(":connectors-editors:redmine-editor")
    compile project(":connectors-editors:editor-trello")

    implementation("javax.servlet:javax.servlet-api:3.1.0")
    implementation("org.eclipse.jetty:jetty-continuation:${jettyVersion}")
    implementation("org.eclipse.jetty:jetty-server:${jettyVersion}")
    implementation("org.eclipse.jetty.websocket:websocket-server:${jettyVersion}")
    implementation("org.eclipse.jetty.websocket:javax-websocket-server-impl:${jettyVersion}") {
        exclude(module: "javax.websocket-client-api")
    }

    testCompile project(":test-utilities")
    testCompile libraries.festassert
    testCompile libraries.assertJ
}

application {
    mainClassName = "com.taskadapter.app.TALauncher"
    // "applicationName" name is used for the final distributive file name prefix, with version attached to it.
    applicationName = "taskadapter"
}
startScripts {

    // this will be used as the name for generated launch scripts
    applicationName = "taskadapter"

    ext.jvmOpts = "-Xmx512m"
    // "defaultJvmOpts" is a special variable recognized by "application" plugin.
    // it is used to set JVM options
    defaultJvmOpts = [ext.jvmOpts]

    /*
    The gradle application task handily helps in creating a CLI program from a gradle project.
    However, in the Windows batch file, the classpath is set by manually specifying every jar on the classpath, e.g.:

    set CLASSPATH=%APP_HOME%\lib\some.jar;%APP_HOME%\lib\another.jar;%APP_HOME%\lib\yet-another.jar

    and then using that with the -classpath switch of your java executable. If you have a large classpath,
    you are in imminent danger of overflowing CMD's puny line length restrictions,
    resulting in a the input line is too long error.
    the following classpath setting makes sure that all jars from "lib" folder are added to classpath instead, like this:

        set CLASSPATH=%APP_HOME%\lib\*

     */
    classpath = files( '$APP_HOME/lib/*' )

    doLast {
        // add "--openTaskAdapterPageInWebBrowser" at the end of the command line parameters
        def WIN_REPLACE_ARG2 = "com.taskadapter.app.TALauncher "
        def WIN_REPLACE_ARG2_WITH = WIN_REPLACE_ARG2 + " --openTaskAdapterPageInWebBrowser "
        windowsScript.text = windowsScript.text.replace(WIN_REPLACE_ARG2, WIN_REPLACE_ARG2_WITH)

        def LIN_REPLACE_ARG2 = "com.taskadapter.app.TALauncher "
        def LIN_REPLACE_ARG2_WITH = LIN_REPLACE_ARG2 + " --openTaskAdapterPageInWebBrowser "
        unixScript.text = unixScript.text.replace(LIN_REPLACE_ARG2, LIN_REPLACE_ARG2_WITH)
    }
}

vaadin {
    pnpmEnable = true
}
